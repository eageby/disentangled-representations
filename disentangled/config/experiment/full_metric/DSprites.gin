include 'config.gin'

import disentangled.metric.factorvae_score
import disentangled.metric.callback
import disentangled.metric.mig2

run_training.callbacks = [@MIG/MetricCallback(), @FactorVAE_Score/MetricCallback(), @OperativeConfigCallback(), @tf.keras.callbacks.TensorBoard()]

OperativeConfigCallback.log_dir =%LOGS_PATH

MetricCallback.interval = 25000
# FactorVAE_Score 
# ==============================================================================
FactorVAE_Score/MetricCallback.log_dir = %LOGS_PATH
FactorVAE_Score/MetricCallback.metric_fn= @factorvae_score
FactorVAE_Score/MetricCallback.metric_name = 'FactorVAE_Score' 

factorvae_score.dataset=@DSprites.ordered.load()
DSprites.ordered.load.num_parallel_calls=%PARALLEL_CALLS

factorvae_score.training_votes=800
factorvae_score.subset=1000
factorvae_score.tolerance=1e-2
factorvae_score.progress_bar=False

# Mutual Information Gap
# ==============================================================================
MIG/MetricCallback.log_dir = %LOGS_PATH
MIG/MetricCallback.metric_fn= @mutual_information_gap
MIG/MetricCallback.metric_name = 'MIG' 

mutual_information_gap.dataset=@DSprites.supervised()
DSprites.supervised.num_parallel_calls=%PARALLEL_CALLS

mutual_information_gap.batches=180
mutual_information_gap.batch_size= 4096
mutual_information_gap.progress_bar=False

# Shuffling
# ==============================================================================
DSprites.pipeline.shuffle = @tf.data.Dataset.shuffle
DSprites.supervised.shuffle = @tf.data.Dataset.shuffle
DSprites.ordered.load.shuffle = @tf.data.Dataset.shuffle

run_training.save = False
